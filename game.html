<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Reflect</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style type="text/css">
      body {
        margin: 0;
        background-color: lightgoldenrodyellow;
      }
    </style>
  </head>
  <body>
    <script type="text/javascript">
      const SCREEN_WIDTH = 240;
      const SCREEN_HEIGHT = 360;

      const BLOCK_SIZE = 40;
      const CELL_SIZE = 38;

      const SPRITE_NAMES = {
        "/": "oblique_mirror",
        "\\": "reverse_oblique_mirror",
        o: "mirror_ball",
      };

      // https://sashamaps.net/docs/resources/20-colors/
      const COLOURS = [
        "#e6194B",
        "#3cb44b",
        "#ffe119",
        "#4363d8",
        "#f58231",
        "#42d4f4",
        "#f032e6",
        "#fabed4",
        "#469990",
        "#dcbeff",
        "#9A6324",
        "#fffac8",
        "#800000",
        "#aaffc3",
        "#000075",
        "#a9a9a9",
      ].map((hex) => Phaser.Display.Color.HexStringToColor(hex).color);

      function blockIndexToCoord(i, j) {
        const x = i * BLOCK_SIZE + BLOCK_SIZE / 2;
        const y = j * BLOCK_SIZE + BLOCK_SIZE / 2;
        const y_offset = 40;
        return [x, y + y_offset];
      }

      class Board {
        constructor(text) {
          this.fullBoard = text
            .split("\n")
            .filter((line) => line.trim().length > 0 && !line.startsWith("#"))
            .map((line) => line.split(""));
          this.n = this.fullBoard.length - 2;
          this.hiddenBlocks = this.fullBoard
            .slice(1, this.n + 1)
            .map((arr) => arr.slice(1, this.n + 1));
        }

        get pieces() {
          return this.hiddenBlocks
            .flat()
            .filter((piece) => piece != ".")
            .sort();
        }

        // Return all the edge locations in a predictable order.
        *edgeLocations() {
          for (let x = 1; x <= this.n; x++) {
            yield [x, 0];
          }
          for (let y = 1; y <= this.n; y++) {
            yield [0, y];
          }
          for (let x = 1; x <= this.n; x++) {
            yield [x, this.n + 1];
          }
          for (let y = 1; y <= this.n; y++) {
            yield [this.n + 1, y];
          }
        }

        // Return all the beam names ("A", "B", etc) in sorted order
        get beamNames() {
          return [...this.edgeLocations()]
            .map((loc) => this.fullBoard[loc[1]][loc[0]])
            .filter((piece) => piece != ".")
            .sort()
            .filter((value, index, array) => array.indexOf(value) === index); // unique
        }

        getPath(x, y) {
          const n1 = this.n + 1;
          const path = [];
          path.push([x, y]);
          let dx = 0;
          let dy = 0;
          if (x == 0) {
            dx = 1;
            dy = 0;
          } else if (x == n1) {
            dx = -1;
            dy = 0;
          } else if (y == 0) {
            dx = 0;
            dy = 1;
          } else if (y == n1) {
            dx = 0;
            dy = -1;
          }
          x += dx;
          y += dy;
          path.push([x, y]);
          while (true) {
            if ([0, n1].includes(x) || [0, n1].includes(y)) {
              // TODO: check end point has same path label
              break;
            }
            const val = this.fullBoard[y][x];
            if (val == "/") {
              [dx, dy] = [-dy, -dx];
            } else if (val == "\\") {
              [dx, dy] = [dy, dx];
            } else if (val == "o") {
              [dx, dy] = [-dx, -dy];
            }
            x += dx;
            y += dy;
            path.push([x, y]);
          }
          return path;
        }
        get beamPaths() {
          const paths = [];
          for (let beamName of this.beamNames) {
            let startLoc = null;
            for (let loc of this.edgeLocations()) {
              if (this.fullBoard[loc[1]][loc[0]] == beamName) {
                startLoc = loc;
                const path = this.getPath(loc[0], loc[1]);
                paths.push(path);
                break;
              }
            }
          }
          return paths;
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: SCREEN_WIDTH,
        height: SCREEN_HEIGHT,
        backgroundColor: "#FFFFFF",
        scene: {
          preload: preload,
          create: create,
          update: update,
        },
      };

      const today = new Date().toISOString().split("T")[0];
      const game = new Phaser.Game(config);

      function preload() {
        this.load.image("logo", "sprites/reflect.png");
        for (const name of Object.values(SPRITE_NAMES)) {
          this.load.image(name, `sprites/${name}_tr.png`);
        }
        this.load.text("puzzle", `puzzles/puzzle-${today}.txt`);
      }

      function create() {
        const puzzle = this.cache.text.get("puzzle");
        const board = new Board(puzzle);
        const n = board.n;
        const hiddenBlocks = board.hiddenBlocks;
        const beamPaths = board.beamPaths;
        const pieces = board.pieces;
        const boardValues = Array.from(Array(n), () => Array(n).fill("."));

        let gameOver = false;

        // Logo
        this.add.image(120, 20, "logo");

        // Beams
        const beamGraphics = this.add.graphics();
        const beamPathGraphics = this.add.graphics();
        beamPathGraphics.visible = false;
        for (var bi = 0; bi < beamPaths.length; bi++) {
          const beamPath = beamPaths[bi];
          for (var bj = 0; bj < beamPath.length - 1; bj++) {
            const start = beamPath[bj];
            const end = beamPath[bj + 1];
            const [x0, y0] = blockIndexToCoord(start[0], start[1]);
            const [x1, y1] = blockIndexToCoord(end[0], end[1]);

            beamPathGraphics.lineStyle(5, COLOURS[bi]);
            beamPathGraphics.lineBetween(x0, y0, x1, y1);
          }
          const start = beamPath[0];
          const end = beamPath[beamPath.length - 1];
          for (let [i, j] of [start, end]) {
            beamGraphics.lineStyle(5, COLOURS[bi]);
            const [x, y] = blockIndexToCoord(i, j);
            if (i == 0) {
              beamGraphics.lineBetween(5, y, 40, y);
            } else if (i == n + 1) {
              beamGraphics.lineBetween(200, y, 235, y);
            } else if (j == 0) {
              beamGraphics.lineBetween(x, 45, x, 80);
            } else if (j == n + 1) {
              beamGraphics.lineBetween(x, 240, x, 275);
            }
          }
        }

        // Board lines
        const boardGraphics = this.add.graphics();
        boardGraphics.lineStyle(1, "black");

        for (var x = BLOCK_SIZE; x < BLOCK_SIZE * (n + 2); x += BLOCK_SIZE) {
          boardGraphics.lineBetween(
            x,
            BLOCK_SIZE + 40,
            x,
            BLOCK_SIZE * (n + 1) + 40
          );
        }
        for (var y = BLOCK_SIZE; y < BLOCK_SIZE * (n + 2); y += BLOCK_SIZE) {
          boardGraphics.lineBetween(
            BLOCK_SIZE,
            y + 40,
            BLOCK_SIZE * (n + 1),
            y + 40
          );
        }

        // Cells
        const cellGraphics = this.add.graphics();
        cellGraphics.fillStyle(0xf0f8ff);

        for (var i = 0; i < n; i++) {
          for (var j = 0; j < n; j++) {
            const [x, y] = blockIndexToCoord(i + 1, j + 1);
            const zone = this.add
              .zone(x, y, CELL_SIZE, CELL_SIZE)
              .setRectangleDropZone(CELL_SIZE, CELL_SIZE)
              .setData("loc", [i, j]);

            cellGraphics.fillRect(
              zone.x - zone.input.hitArea.width / 2,
              zone.y - zone.input.hitArea.height / 2,
              zone.input.hitArea.width,
              zone.input.hitArea.height
            );
          }
        }

        for (var i = 0; i < pieces.length; i++) {
          let [x, y] = blockIndexToCoord((i % 4) + 1, Math.floor(i / 4));
          y += 240;

          const zone = this.add
            .zone(x, y, CELL_SIZE, CELL_SIZE)
            .setRectangleDropZone(CELL_SIZE, CELL_SIZE);

          cellGraphics.fillRect(
            zone.x - zone.input.hitArea.width / 2,
            zone.y - zone.input.hitArea.height / 2,
            zone.input.hitArea.width,
            zone.input.hitArea.height
          );
        }

        for (var i = 0; i < pieces.length; i++) {
          let [x, y] = blockIndexToCoord((i % 4) + 1, Math.floor(i / 4));
          y += 240;

          const image = this.add
            .image(x, y, SPRITE_NAMES[pieces[i]])
            .setInteractive();
          image.setData("piece", pieces[i]);
          this.input.setDraggable(image);
        }

        this.input.on("drag", function (pointer, gameObject, dragX, dragY) {
          // update image coordinates as it is dragged
          gameObject.x = dragX;
          gameObject.y = dragY;
        });

        this.input.on("dragleave", function (pointer, gameObject, dropZone) {
          // remove image from drop zone
          if (dropZone.data && dropZone.data.get("image") === gameObject) {
            dropZone.data.remove("image");
          }
        });

        this.input.on(
          "drop",
          function (pointer, gameObject, dropZone) {
            if (dropZone.data && dropZone.data.get("image") !== undefined) {
              // drop zone already occupied - reset position
              gameObject.x = gameObject.input.dragStartX;
              gameObject.y = gameObject.input.dragStartY;
              return;
            }

            gameObject.x = dropZone.x;
            gameObject.y = dropZone.y;
            dropZone.setData("image", gameObject);
            if (dropZone.data.get("loc") !== undefined) {
              // drop zone is on board
              if (gameObject.data.get("loc") !== undefined) {
                // remove piece from board
                const [i, j] = gameObject.data.get("loc");
                boardValues[j][i] = ".";
                gameObject.data.remove("loc");
              }
              // add piece to the board
              const [i, j] = dropZone.data.get("loc");
              gameObject.setData("loc", [i, j]);
              boardValues[j][i] = gameObject.data.get("piece");

              // test if game over
              if (JSON.stringify(boardValues) == JSON.stringify(hiddenBlocks)) {
                cellGraphics.visible = false;
                beamPathGraphics.visible = true;
                gameOver = true;
                // disable dragging
                let images = this.children.list.filter(
                  (x) => x instanceof Phaser.GameObjects.Sprite
                );
                images.forEach((image) =>
                  this.input.setDraggable(image, false)
                );
              }
            } else if (gameObject.data.get("loc") !== undefined) {
              // drop zone is not on board, but piece was previously on board
              // remove piece from board
              const [i, j] = gameObject.data.get("loc");
              boardValues[j][i] = ".";
              gameObject.data.remove("loc");
            }
          },
          this
        );

        this.input.on("dragend", function (pointer, gameObject, dropped) {
          if (!dropped) {
            // not dropped on drop zone - reset position
            gameObject.x = gameObject.input.dragStartX;
            gameObject.y = gameObject.input.dragStartY;
          }
        });
      }

      function update() {}
    </script>
  </body>
</html>
